---
title: 首屏骨架屏减少白屏
date: 2024-09-22 21:55:05
tags:
categories: 性能优化
---

## 背景

用户从输入 `url` 到打开页面，经历的步骤 [参考这里](https://popring.github.io/2021/03/06/%E7%AE%80%E5%8D%95%E8%81%8A/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%BB%8F%E8%BF%87%E4%BA%86%E4%BB%80%E4%B9%88/) ，而现在前端应用程序通常都会使用 `React` 、`Vue` 、 `Angular` 、 `Solid` 等库框架进行开发，由框架层面进行工程化进行统一管理。

而这也导致一个问题就是，由以上框架开发的 `SPA` 应用生成的 html 应用中，通常只包含一个 `<div id="#app"></div>` ，剩下的内容都是通过后续的 `script` 运行时进行渲染。

此时用户加载到的 `html` 就为白屏，等脚本解析执行后，才会主线渲染内容。于是就出现了 `SSR （服务端渲染）`，直接在服务端就将内容渲染好返回到前端，但是此方法需要项目整体改造，成本略高。我们也可以使用另一种方案，首屏骨架图渲染减少白屏。

## 原理

直接将骨架图写在 `html` 中，等实际内容加载完毕后直接将骨架图替换为内容。

## 生成骨架屏方式

- 单独写一套骨架屏样式，然后注入
- 使用骨架屏图片
- 使用自动生成骨架屏形式
  - `page-skeleton-webpack-plugin` ，这个插件目前已经没有维护了，（而且我也运行不起来，不是很推荐）
  - 使用 `chrome 插件` 生成骨架屏，比如 `@killblanks/skeleton-ext` ，试了好几个，目前只有这个还生效，不过生成之后还是需要微调一下样式
  - 自己写一套，其实原理并不复杂，简而言之就是将页面的文字和图片替换为骨架图形式展示。这里我用 chatgpt 生成了一段代码供参考，下面展示下效果图，分别用 demo页、掘金、小红书、淘宝、京东测试了下生成的骨架图，可以看出对于结构复杂页面生成还是会有点问题，如果要实际用，还是需要微调一下样式。

![](https://raw.githubusercontent.com/popring/assets-repo/master/img/202409240136523.png)
![](https://raw.githubusercontent.com/popring/assets-repo/master/img/202409240136518.png)
![](https://raw.githubusercontent.com/popring/assets-repo/master/img/202409240136520.png)
![](https://raw.githubusercontent.com/popring/assets-repo/master/img/202409240136521.png)
![](https://raw.githubusercontent.com/popring/assets-repo/master/img/202409240136522.png)

下面这段代码可以复制到浏览器中执行，并预览生成的效果；如果想要使用生成的骨架屏，可以只在页面中复制dom `#skeleton-overlay` 。

```js
// 递归生成骨架图
function processElement(el, skeletonOverlay, bodyRect) {
  const children = el.children;

  if (children.length > 0) {
    for (let i = 0; i < children.length; i++) {
      processElement(children[i], skeletonOverlay, bodyRect);
    }
  } else {
    const rect = el.getBoundingClientRect();
    if (rect.width > 0 && rect.height > 0) {
      const skeletonElement = document.createElement('div');
      skeletonElement.className = 'skeleton-box';
      skeletonElement.style.position = 'absolute';
      skeletonElement.style.top = rect.top - bodyRect.top + 'px';
      skeletonElement.style.left = rect.left - bodyRect.left + 'px';
      skeletonElement.style.width = rect.width + 'px';
      skeletonElement.style.height = rect.height + 'px';
      skeletonOverlay.appendChild(skeletonElement);
    }
  }
}

// 覆盖页面并生成骨架图
function generateSkeleton() {
  if (document.getElementById('skeleton-overlay')) return;

  const skeletonOverlay = document.createElement('div');
  skeletonOverlay.id = 'skeleton-overlay';
  skeletonOverlay.style.position = 'fixed';
  skeletonOverlay.style.top = 0;
  skeletonOverlay.style.left = 0;
  skeletonOverlay.style.width = '100%';
  skeletonOverlay.style.height = '100%';
  skeletonOverlay.style.zIndex = 9999;
  skeletonOverlay.style.backgroundColor = 'rgba(255, 255, 255, 1)';

  const bodyRect = document.body.getBoundingClientRect();

  document
    .querySelectorAll('div, p, h1, h2, h3, h4, h5, h6, a, img, span, em')
    .forEach((el) => {
      processElement(el, skeletonOverlay, bodyRect);
    });

  insertSkeletonStyles(skeletonOverlay);
  document.body.appendChild(skeletonOverlay);
}

// 骨架图样式函数
function insertSkeletonStyles(skeletonOverlay) {
  const skeletonStyles = `
    .skeleton-box {
      background-color: #f0f0f0;
      animation: skeleton-loading 1.5s infinite;
      border-radius: 4px;
    }
    @keyframes skeleton-loading {
      0% {
        background-color: #f0f0f0;
      }
      50% {
        background-color: #e0e0e0;
      }
      100% {
        background-color: #f0f0f0;
      }
    }
  `;

  const styleSheet = document.createElement('style');
  styleSheet.type = 'text/css';
  styleSheet.innerText = skeletonStyles;
  skeletonOverlay.appendChild(styleSheet);
}

// 切换骨架图的显示和隐藏
function toggleSkeleton() {
  const skeletonOverlay = document.getElementById('skeleton-overlay');
  if (skeletonOverlay) {
    skeletonOverlay.style.display =
      skeletonOverlay.style.display === 'none' ? 'block' : 'none';
  } else {
    generateSkeleton();
  }
}

// 将核心函数绑定到 window 对象上
window.generateSkeleton = generateSkeleton;
window.toggleSkeleton = toggleSkeleton;
```

## 注入代码 1 - 注入进 #app 内

比如这里我使用的是 `vite` 打包工具，'webpack' 同理，也有同类型的工具可以直接用。

首先需要写一个插件，在生成时修改 html 代码

```js
// /plugins/skeletonPlugin.ts
import { PluginOption } from 'vite';
import { join } from 'path';

const filename = join(__dirname, './homeSkeleton.js');

export function SkeletonPlugin(): PluginOption {
  return {
    name: 'SkeletonPlugin',
    async transformIndexHtml(html) {
      const content = (await import(filename)).default;
      const code = `
      <script>
var map = ${JSON.stringify(content)}
var pathname = window.location.pathname
var target = map[pathname]
var content = target && target.html || ''
document.write(content)
</script>
      `;
      return html.replace(/__SKELETON_CONTENT__/, code);
    },
  };
}
```

html 中在 `id="root"` 中增加内容 `__SKELETON_CONTENT__` ，方便填充骨架屏。

```html
<!-- /index.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root">__SKELETON_CONTENT__</div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

```js
// /plugins/homeSkeleton.js
export default {
  '/home': {
    pathname: '/home',
    html: `<div>xxx 骨架图内容 xxx</div>`,
  },
};
```

生成结果如下，不过需要注意的是页面入口的 `script` 需要设置为 `defer` 才会生效，否则加载入口 `script` 会阻塞后续代码执行，也就相当于事骨架图代码不会生效。

![](https://raw.githubusercontent.com/popring/assets-repo/master/img/202409222315103.png)

粗糙一点实现，在 `plugins/skeletonPlugin.ts` 中暴力将所有 `script` 都新增 `defer` ，当然这种操作不优雅，有待优化。

```js
// /plugins/skeletonPlugin.ts
import { PluginOption } from 'vite';
import { join } from 'path';

const filename = join(__dirname, './homeSkeleton.js');

export function SkeletonPlugin(): PluginOption {
  return {
    name: 'SkeletonPlugin',
    async transformIndexHtml(html) {
      // 新增
      const modifiedHtml = html.replace('<script', '<script defer')
      const content = (await import(filename)).default;
      const code = `
      <script>
var map = ${JSON.stringify(content)}
var pathname = window.location.pathname
var target = map[pathname]
var content = target && target.html || ''
document.write(content)
</script>
      `;
      return modifiedHtml.replace(/__SKELETON_CONTENT__/, code);
    },
  };
}
```

至此，该方案基本已经结束，但是实际应用时，发现还是白屏闪一下，是因为在框架侧加载页面时异步的，先进行渲染了根路由信息，然后才会渲染具体路由页面的信息，所以方案还是有待完善，于是出现了下面一种。


## 注入代码 2 - 显示在页面最上层

将骨架屏渲染在一个空 `div` 上，然后用样式 `fixed` 在页面的最上层，然后监听页面实际渲染的页面是否渲染完成，实际页面渲染完之后将骨架图隐藏，就可以在视觉上进行实现了。

实现效果如图

![](https://raw.githubusercontent.com/popring/assets-repo/master/img/202409240252167.gif)

**最终代码**
https://github.com/popring/vite-skeleton

> 参考
> 
> [Vue项目骨架屏注入实践](https://juejin.cn/post/6844903661726859272)
> 
> [一个前端非侵入式骨架屏自动生成方案](https://juejin.cn/post/7109083708463775752)
> 