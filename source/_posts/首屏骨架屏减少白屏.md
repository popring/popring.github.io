---
title: 首屏骨架屏减少白屏
date: 2024-09-22 21:55:05
tags:
categories: 性能优化
---

## 背景

用户从输入 `url` 到打开页面，经历的步骤 [参考这里](https://popring.github.io/2021/03/06/%E7%AE%80%E5%8D%95%E8%81%8A/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%BB%8F%E8%BF%87%E4%BA%86%E4%BB%80%E4%B9%88/) ，而现在前端应用程序通常都会使用 `React` 、`Vue` 、 `Angular` 、 `Solid` 等库框架进行开发，由框架层面进行工程化进行统一管理。

而这也导致一个问题就是，由以上框架开发的 `SPA` 应用生成的 html 应用中，通常只包含一个 `<div id="#app"></div>` ，剩下的内容都是通过后续的 `script` 运行时进行渲染。

此时用户加载到的 `html` 就为白屏，等脚本解析执行后，才会主线渲染内容。于是就出现了 `SSR （服务端渲染）`，直接在服务端就将内容渲染好返回到前端，但是此方法需要项目整体改造，成本略高。我们也可以使用另一种方案，首屏骨架图渲染减少白屏。

## 原理

直接将骨架图写在 `html` 中，等实际内容加载完毕后直接将骨架图替换为内容。

## 生成骨架屏方式

- 单独写一套骨架屏样式，然后注入
- 使用骨架屏图片
- 使用自动生成骨架屏形式
  - `page-skeleton-webpack-plugin` ，不过这个插件目前已经没有维护了
  - 使用 `chrome 插件` 生成骨架屏，比如 `@killblanks/skeleton-ext` ，试了好几个，目前只有这个还生效，不过生成之后还是需要微调一下样式

## 注入代码

比如这里我使用的是 `vite` 打包工具，'webpack' 同理，也有同类型的工具可以直接用。

首先需要写一个插件，在生成时修改 html 代码

```js
// /plugins/skeletonPlugin.ts
import { PluginOption } from 'vite';
import { join } from 'path';

const filename = join(__dirname, './homeSkeleton.js');

export function SkeletonPlugin(): PluginOption {
  return {
    name: 'SkeletonPlugin',
    async transformIndexHtml(html) {
      const content = (await import(filename)).default;
      const code = `
      <script>
var map = ${JSON.stringify(content)}
var pathname = window.location.pathname
var target = map[pathname]
var content = target && target.html || ''
document.write(content)
</script>
      `;
      return html.replace(/__SKELETON_CONTENT__/, code);
    },
  };
}
```

html 中在 `id="root"` 中增加内容 `__SKELETON_CONTENT__` ，方便填充骨架屏。

```html
<!-- /index.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root">__SKELETON_CONTENT__</div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

```js
// /plugins/homeSkeleton.js
export default {
  '/home': {
    pathname: '/home',
    html: `<div>xxx 骨架图内容 xxx</div>`,
  },
};
```

生成结果如下，不过需要注意的是页面入口的 `script` 需要设置为 `defer` 才会生效，否则加载入口 `script` 会阻塞后续代码执行，也就相当于事骨架图代码不会生效。

![](https://raw.githubusercontent.com/popring/assets-repo/master/img/202409222315103.png)

粗糙一点实现，在 `plugins/skeletonPlugin.ts` 中暴力将所有 `script` 都新增 `defer` ，当然这种操作不优雅，有待优化。

```js
// /plugins/skeletonPlugin.ts
import { PluginOption } from 'vite';
import { join } from 'path';

const filename = join(__dirname, './homeSkeleton.js');

export function SkeletonPlugin(): PluginOption {
  return {
    name: 'SkeletonPlugin',
    async transformIndexHtml(html) {
      // 新增
      const modifiedHtml = html.replace('<script', '<script defer')
      const content = (await import(filename)).default;
      const code = `
      <script>
var map = ${JSON.stringify(content)}
var pathname = window.location.pathname
var target = map[pathname]
var content = target && target.html || ''
document.write(content)
</script>
      `;
      return modifiedHtml.replace(/__SKELETON_CONTENT__/, code);
    },
  };
}

```

> 参考
> 
> [Vue项目骨架屏注入实践](https://juejin.cn/post/6844903661726859272)
> 
> [一个前端非侵入式骨架屏自动生成方案](https://juejin.cn/post/7109083708463775752)
> 